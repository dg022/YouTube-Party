{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Transport = require('../transport');\n\nvar parser = require('engine.io-parser');\n\nvar util = require('util');\n\nvar debug = require('debug')('engine:ws');\n/**\n * Export the constructor.\n */\n\n\nmodule.exports = WebSocket;\n/**\n * WebSocket transport\n *\n * @param {http.IncomingMessage}\n * @api public\n */\n\nfunction WebSocket(req) {\n  Transport.call(this, req);\n  var self = this;\n  this.socket = req.websocket;\n  this.socket.on('message', this.onData.bind(this));\n  this.socket.once('close', this.onClose.bind(this));\n  this.socket.on('error', this.onError.bind(this));\n  this.socket.on('headers', onHeaders);\n  this.writable = true;\n  this.perMessageDeflate = null;\n\n  function onHeaders(headers) {\n    self.emit('headers', headers);\n  }\n}\n/**\n * Inherits from Transport.\n */\n\n\nutil.inherits(WebSocket, Transport);\n/**\n * Transport name\n *\n * @api public\n */\n\nWebSocket.prototype.name = 'websocket';\n/**\n * Advertise upgrade support.\n *\n * @api public\n */\n\nWebSocket.prototype.handlesUpgrades = true;\n/**\n * Advertise framing support.\n *\n * @api public\n */\n\nWebSocket.prototype.supportsFraming = true;\n/**\n * Processes the incoming data.\n *\n * @param {String} encoded packet\n * @api private\n */\n\nWebSocket.prototype.onData = function (data) {\n  debug('received \"%s\"', data);\n  Transport.prototype.onData.call(this, data);\n};\n/**\n * Writes a packet payload.\n *\n * @param {Array} packets\n * @api private\n */\n\n\nWebSocket.prototype.send = function (packets) {\n  var self = this;\n\n  for (var i = 0; i < packets.length; i++) {\n    var packet = packets[i];\n    parser.encodePacket(packet, self.supportsBinary, send);\n  }\n\n  function send(data) {\n    debug('writing \"%s\"', data); // always creates a new object since ws modifies it\n\n    var opts = {};\n\n    if (packet.options) {\n      opts.compress = packet.options.compress;\n    }\n\n    if (self.perMessageDeflate) {\n      var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\n\n      if (len < self.perMessageDeflate.threshold) {\n        opts.compress = false;\n      }\n    }\n\n    self.writable = false;\n    self.socket.send(data, opts, onEnd);\n  }\n\n  function onEnd(err) {\n    if (err) return self.onError('write error', err.stack);\n    self.writable = true;\n    self.emit('drain');\n  }\n};\n/**\n * Closes the transport.\n *\n * @api private\n */\n\n\nWebSocket.prototype.doClose = function (fn) {\n  debug('closing');\n  this.socket.close();\n  fn && fn();\n};","map":{"version":3,"sources":["C:/Users/david/react/YouTubeClone/client/node_modules/engine.io/lib/transports/websocket.js"],"names":["Transport","require","parser","util","debug","module","exports","WebSocket","req","call","self","socket","websocket","on","onData","bind","once","onClose","onError","onHeaders","writable","perMessageDeflate","headers","emit","inherits","prototype","name","handlesUpgrades","supportsFraming","data","send","packets","i","length","packet","encodePacket","supportsBinary","opts","options","compress","len","Buffer","byteLength","threshold","onEnd","err","stack","doClose","fn","close"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar util = require('util');\nvar debug = require('debug')('engine:ws');\n\n/**\n * Export the constructor.\n */\n\nmodule.exports = WebSocket;\n\n/**\n * WebSocket transport\n *\n * @param {http.IncomingMessage}\n * @api public\n */\n\nfunction WebSocket (req) {\n  Transport.call(this, req);\n  var self = this;\n  this.socket = req.websocket;\n  this.socket.on('message', this.onData.bind(this));\n  this.socket.once('close', this.onClose.bind(this));\n  this.socket.on('error', this.onError.bind(this));\n  this.socket.on('headers', onHeaders);\n  this.writable = true;\n  this.perMessageDeflate = null;\n\n  function onHeaders (headers) {\n    self.emit('headers', headers);\n  }\n}\n\n/**\n * Inherits from Transport.\n */\n\nutil.inherits(WebSocket, Transport);\n\n/**\n * Transport name\n *\n * @api public\n */\n\nWebSocket.prototype.name = 'websocket';\n\n/**\n * Advertise upgrade support.\n *\n * @api public\n */\n\nWebSocket.prototype.handlesUpgrades = true;\n\n/**\n * Advertise framing support.\n *\n * @api public\n */\n\nWebSocket.prototype.supportsFraming = true;\n\n/**\n * Processes the incoming data.\n *\n * @param {String} encoded packet\n * @api private\n */\n\nWebSocket.prototype.onData = function (data) {\n  debug('received \"%s\"', data);\n  Transport.prototype.onData.call(this, data);\n};\n\n/**\n * Writes a packet payload.\n *\n * @param {Array} packets\n * @api private\n */\n\nWebSocket.prototype.send = function (packets) {\n  var self = this;\n\n  for (var i = 0; i < packets.length; i++) {\n    var packet = packets[i];\n    parser.encodePacket(packet, self.supportsBinary, send);\n  }\n\n  function send (data) {\n    debug('writing \"%s\"', data);\n\n    // always creates a new object since ws modifies it\n    var opts = {};\n    if (packet.options) {\n      opts.compress = packet.options.compress;\n    }\n\n    if (self.perMessageDeflate) {\n      var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;\n      if (len < self.perMessageDeflate.threshold) {\n        opts.compress = false;\n      }\n    }\n\n    self.writable = false;\n    self.socket.send(data, opts, onEnd);\n  }\n\n  function onEnd (err) {\n    if (err) return self.onError('write error', err.stack);\n    self.writable = true;\n    self.emit('drain');\n  }\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nWebSocket.prototype.doClose = function (fn) {\n  debug('closing');\n  this.socket.close();\n  fn && fn();\n};\n"]},"metadata":{},"sourceType":"script"}