{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar debug = require('debug')('engine:socket');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Socket;\n/**\n * Client class (abstract).\n *\n * @api private\n */\n\nfunction Socket(id, server, transport, req) {\n  this.id = id;\n  this.server = server;\n  this.upgrading = false;\n  this.upgraded = false;\n  this.readyState = 'opening';\n  this.writeBuffer = [];\n  this.packetsFn = [];\n  this.sentCallbackFn = [];\n  this.cleanupFn = [];\n  this.request = req; // Cache IP since it might not be in the req later\n\n  if (req.websocket && req.websocket._socket) {\n    this.remoteAddress = req.websocket._socket.remoteAddress;\n  } else {\n    this.remoteAddress = req.connection.remoteAddress;\n  }\n\n  this.checkIntervalTimer = null;\n  this.upgradeTimeoutTimer = null;\n  this.pingTimeoutTimer = null;\n  this.setTransport(transport);\n  this.onOpen();\n}\n/**\n * Inherits from EventEmitter.\n */\n\n\nutil.inherits(Socket, EventEmitter);\n/**\n * Called upon transport considered open.\n *\n * @api private\n */\n\nSocket.prototype.onOpen = function () {\n  this.readyState = 'open'; // sends an `open` packet\n\n  this.transport.sid = this.id;\n  this.sendPacket('open', JSON.stringify({\n    sid: this.id,\n    upgrades: this.getAvailableUpgrades(),\n    pingInterval: this.server.pingInterval,\n    pingTimeout: this.server.pingTimeout\n  }));\n\n  if (this.server.initialPacket) {\n    this.sendPacket('message', this.server.initialPacket);\n  }\n\n  this.emit('open');\n  this.setPingTimeout();\n};\n/**\n * Called upon transport packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.onPacket = function (packet) {\n  if ('open' === this.readyState) {\n    // export packet event\n    debug('packet');\n    this.emit('packet', packet); // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n\n    this.setPingTimeout();\n\n    switch (packet.type) {\n      case 'ping':\n        debug('got ping');\n        this.sendPacket('pong');\n        this.emit('heartbeat');\n        break;\n\n      case 'error':\n        this.onClose('parse error');\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with closed socket');\n  }\n};\n/**\n * Called upon transport error.\n *\n * @param {Error} error object\n * @api private\n */\n\n\nSocket.prototype.onError = function (err) {\n  debug('transport error');\n  this.onClose('transport error', err);\n};\n/**\n * Sets and resets ping timeout timer based on client pings.\n *\n * @api private\n */\n\n\nSocket.prototype.setPingTimeout = function () {\n  var self = this;\n  clearTimeout(self.pingTimeoutTimer);\n  self.pingTimeoutTimer = setTimeout(function () {\n    self.onClose('ping timeout');\n  }, self.server.pingInterval + self.server.pingTimeout);\n};\n/**\n * Attaches handlers for the given transport.\n *\n * @param {Transport} transport\n * @api private\n */\n\n\nSocket.prototype.setTransport = function (transport) {\n  var onError = this.onError.bind(this);\n  var onPacket = this.onPacket.bind(this);\n  var flush = this.flush.bind(this);\n  var onClose = this.onClose.bind(this, 'transport close');\n  this.transport = transport;\n  this.transport.once('error', onError);\n  this.transport.on('packet', onPacket);\n  this.transport.on('drain', flush);\n  this.transport.once('close', onClose); // this function will manage packet events (also message callbacks)\n\n  this.setupSendCallback();\n  this.cleanupFn.push(function () {\n    transport.removeListener('error', onError);\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('drain', flush);\n    transport.removeListener('close', onClose);\n  });\n};\n/**\n * Upgrades socket to the given transport\n *\n * @param {Transport} transport\n * @api private\n */\n\n\nSocket.prototype.maybeUpgrade = function (transport) {\n  debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n  this.upgrading = true;\n  var self = this; // set transport upgrade timer\n\n  self.upgradeTimeoutTimer = setTimeout(function () {\n    debug('client did not complete upgrade - closing transport');\n    cleanup();\n\n    if ('open' === transport.readyState) {\n      transport.close();\n    }\n  }, this.server.upgradeTimeout);\n\n  function onPacket(packet) {\n    if ('ping' === packet.type && 'probe' === packet.data) {\n      transport.send([{\n        type: 'pong',\n        data: 'probe'\n      }]);\n      self.emit('upgrading', transport);\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = setInterval(check, 100);\n    } else if ('upgrade' === packet.type && self.readyState !== 'closed') {\n      debug('got upgrade packet - upgrading');\n      cleanup();\n      self.transport.discard();\n      self.upgraded = true;\n      self.clearTransport();\n      self.setTransport(transport);\n      self.emit('upgrade', transport);\n      self.setPingTimeout();\n      self.flush();\n\n      if (self.readyState === 'closing') {\n        transport.close(function () {\n          self.onClose('forced close');\n        });\n      }\n    } else {\n      cleanup();\n      transport.close();\n    }\n  } // we force a polling cycle to ensure a fast upgrade\n\n\n  function check() {\n    if ('polling' === self.transport.name && self.transport.writable) {\n      debug('writing a noop packet to polling for fast upgrade');\n      self.transport.send([{\n        type: 'noop'\n      }]);\n    }\n  }\n\n  function cleanup() {\n    self.upgrading = false;\n    clearInterval(self.checkIntervalTimer);\n    self.checkIntervalTimer = null;\n    clearTimeout(self.upgradeTimeoutTimer);\n    self.upgradeTimeoutTimer = null;\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('close', onTransportClose);\n    transport.removeListener('error', onError);\n    self.removeListener('close', onClose);\n  }\n\n  function onError(err) {\n    debug('client did not complete upgrade - %s', err);\n    cleanup();\n    transport.close();\n    transport = null;\n  }\n\n  function onTransportClose() {\n    onError('transport closed');\n  }\n\n  function onClose() {\n    onError('socket closed');\n  }\n\n  transport.on('packet', onPacket);\n  transport.once('close', onTransportClose);\n  transport.once('error', onError);\n  self.once('close', onClose);\n};\n/**\n * Clears listeners and timers associated with current transport.\n *\n * @api private\n */\n\n\nSocket.prototype.clearTransport = function () {\n  var cleanup;\n  var toCleanUp = this.cleanupFn.length;\n\n  for (var i = 0; i < toCleanUp; i++) {\n    cleanup = this.cleanupFn.shift();\n    cleanup();\n  } // silence further transport errors and prevent uncaught exceptions\n\n\n  this.transport.on('error', function () {\n    debug('error triggered by discarded transport');\n  }); // ensure transport won't stay open\n\n  this.transport.close();\n  clearTimeout(this.pingTimeoutTimer);\n};\n/**\n * Called upon transport considered closed.\n * Possible reasons: `ping timeout`, `client error`, `parse error`,\n * `transport error`, `server close`, `transport close`\n */\n\n\nSocket.prototype.onClose = function (reason, description) {\n  if ('closed' !== this.readyState) {\n    this.readyState = 'closed';\n    clearTimeout(this.pingTimeoutTimer);\n    clearInterval(this.checkIntervalTimer);\n    this.checkIntervalTimer = null;\n    clearTimeout(this.upgradeTimeoutTimer);\n    var self = this; // clean writeBuffer in next tick, so developers can still\n    // grab the writeBuffer on 'close' event\n\n    process.nextTick(function () {\n      self.writeBuffer = [];\n    });\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.clearTransport();\n    this.emit('close', reason, description);\n  }\n};\n/**\n * Setup and manage send callback\n *\n * @api private\n */\n\n\nSocket.prototype.setupSendCallback = function () {\n  var self = this;\n  this.transport.on('drain', onDrain);\n  this.cleanupFn.push(function () {\n    self.transport.removeListener('drain', onDrain);\n  }); // the message was sent successfully, execute the callback\n\n  function onDrain() {\n    if (self.sentCallbackFn.length > 0) {\n      var seqFn = self.sentCallbackFn.splice(0, 1)[0];\n\n      if ('function' === typeof seqFn) {\n        debug('executing send callback');\n        seqFn(self.transport);\n      } else if (Array.isArray(seqFn)) {\n        debug('executing batch send callback');\n\n        for (var l = seqFn.length, i = 0; i < l; i++) {\n          if ('function' === typeof seqFn[i]) {\n            seqFn[i](self.transport);\n          }\n        }\n      }\n    }\n  }\n};\n/**\n * Sends a message packet.\n *\n * @param {String} message\n * @param {Object} options\n * @param {Function} callback\n * @return {Socket} for chaining\n * @api public\n */\n\n\nSocket.prototype.send = Socket.prototype.write = function (data, options, callback) {\n  this.sendPacket('message', data, options, callback);\n  return this;\n};\n/**\n * Sends a packet.\n *\n * @param {String} packet type\n * @param {String} optional, data\n * @param {Object} options\n * @api private\n */\n\n\nSocket.prototype.sendPacket = function (type, data, options, callback) {\n  if ('function' === typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  if ('closing' !== this.readyState && 'closed' !== this.readyState) {\n    debug('sending packet \"%s\" (%s)', type, data);\n    var packet = {\n      type: type,\n      options: options\n    };\n    if (data) packet.data = data; // exports packetCreate event\n\n    this.emit('packetCreate', packet);\n    this.writeBuffer.push(packet); // add send callback to object, if defined\n\n    if (callback) this.packetsFn.push(callback);\n    this.flush();\n  }\n};\n/**\n * Attempts to flush the packets buffer.\n *\n * @api private\n */\n\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n    debug('flushing buffer to transport');\n    this.emit('flush', this.writeBuffer);\n    this.server.emit('flush', this, this.writeBuffer);\n    var wbuf = this.writeBuffer;\n    this.writeBuffer = [];\n\n    if (!this.transport.supportsFraming) {\n      this.sentCallbackFn.push(this.packetsFn);\n    } else {\n      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n    }\n\n    this.packetsFn = [];\n    this.transport.send(wbuf);\n    this.emit('drain');\n    this.server.emit('drain', this);\n  }\n};\n/**\n * Get available upgrades for this socket.\n *\n * @api private\n */\n\n\nSocket.prototype.getAvailableUpgrades = function () {\n  var availableUpgrades = [];\n  var allUpgrades = this.server.upgrades(this.transport.name);\n\n  for (var i = 0, l = allUpgrades.length; i < l; ++i) {\n    var upg = allUpgrades[i];\n\n    if (this.server.transports.indexOf(upg) !== -1) {\n      availableUpgrades.push(upg);\n    }\n  }\n\n  return availableUpgrades;\n};\n/**\n * Closes the socket and underlying transport.\n *\n * @param {Boolean} optional, discard\n * @return {Socket} for chaining\n * @api public\n */\n\n\nSocket.prototype.close = function (discard) {\n  if ('open' !== this.readyState) return;\n  this.readyState = 'closing';\n\n  if (this.writeBuffer.length) {\n    this.once('drain', this.closeTransport.bind(this, discard));\n    return;\n  }\n\n  this.closeTransport(discard);\n};\n/**\n * Closes the underlying transport.\n *\n * @param {Boolean} discard\n * @api private\n */\n\n\nSocket.prototype.closeTransport = function (discard) {\n  if (discard) this.transport.discard();\n  this.transport.close(this.onClose.bind(this, 'forced close'));\n};","map":{"version":3,"sources":["C:/Users/david/react/YouTubeClone/client/node_modules/engine.io/lib/socket.js"],"names":["EventEmitter","require","util","debug","module","exports","Socket","id","server","transport","req","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","setTransport","onOpen","inherits","prototype","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","pingTimeout","initialPacket","emit","setPingTimeout","onPacket","packet","type","onClose","data","onError","err","self","clearTimeout","setTimeout","bind","flush","once","on","setupSendCallback","push","removeListener","maybeUpgrade","name","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","write","options","callback","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar debug = require('debug')('engine:socket');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Client class (abstract).\n *\n * @api private\n */\n\nfunction Socket (id, server, transport, req) {\n  this.id = id;\n  this.server = server;\n  this.upgrading = false;\n  this.upgraded = false;\n  this.readyState = 'opening';\n  this.writeBuffer = [];\n  this.packetsFn = [];\n  this.sentCallbackFn = [];\n  this.cleanupFn = [];\n  this.request = req;\n\n  // Cache IP since it might not be in the req later\n  if (req.websocket && req.websocket._socket) {\n    this.remoteAddress = req.websocket._socket.remoteAddress;\n  } else {\n    this.remoteAddress = req.connection.remoteAddress;\n  }\n\n  this.checkIntervalTimer = null;\n  this.upgradeTimeoutTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.setTransport(transport);\n  this.onOpen();\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Socket, EventEmitter);\n\n/**\n * Called upon transport considered open.\n *\n * @api private\n */\n\nSocket.prototype.onOpen = function () {\n  this.readyState = 'open';\n\n  // sends an `open` packet\n  this.transport.sid = this.id;\n  this.sendPacket('open', JSON.stringify({\n    sid: this.id,\n    upgrades: this.getAvailableUpgrades(),\n    pingInterval: this.server.pingInterval,\n    pingTimeout: this.server.pingTimeout\n  }));\n\n  if (this.server.initialPacket) {\n    this.sendPacket('message', this.server.initialPacket);\n  }\n\n  this.emit('open');\n  this.setPingTimeout();\n};\n\n/**\n * Called upon transport packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('open' === this.readyState) {\n    // export packet event\n    debug('packet');\n    this.emit('packet', packet);\n\n    // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n    this.setPingTimeout();\n\n    switch (packet.type) {\n      case 'ping':\n        debug('got ping');\n        this.sendPacket('pong');\n        this.emit('heartbeat');\n        break;\n\n      case 'error':\n        this.onClose('parse error');\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with closed socket');\n  }\n};\n\n/**\n * Called upon transport error.\n *\n * @param {Error} error object\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('transport error');\n  this.onClose('transport error', err);\n};\n\n/**\n * Sets and resets ping timeout timer based on client pings.\n *\n * @api private\n */\n\nSocket.prototype.setPingTimeout = function () {\n  var self = this;\n  clearTimeout(self.pingTimeoutTimer);\n  self.pingTimeoutTimer = setTimeout(function () {\n    self.onClose('ping timeout');\n  }, self.server.pingInterval + self.server.pingTimeout);\n};\n\n/**\n * Attaches handlers for the given transport.\n *\n * @param {Transport} transport\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  var onError = this.onError.bind(this);\n  var onPacket = this.onPacket.bind(this);\n  var flush = this.flush.bind(this);\n  var onClose = this.onClose.bind(this, 'transport close');\n\n  this.transport = transport;\n  this.transport.once('error', onError);\n  this.transport.on('packet', onPacket);\n  this.transport.on('drain', flush);\n  this.transport.once('close', onClose);\n  // this function will manage packet events (also message callbacks)\n  this.setupSendCallback();\n\n  this.cleanupFn.push(function () {\n    transport.removeListener('error', onError);\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('drain', flush);\n    transport.removeListener('close', onClose);\n  });\n};\n\n/**\n * Upgrades socket to the given transport\n *\n * @param {Transport} transport\n * @api private\n */\n\nSocket.prototype.maybeUpgrade = function (transport) {\n  debug('might upgrade socket transport from \"%s\" to \"%s\"'\n    , this.transport.name, transport.name);\n\n  this.upgrading = true;\n\n  var self = this;\n\n  // set transport upgrade timer\n  self.upgradeTimeoutTimer = setTimeout(function () {\n    debug('client did not complete upgrade - closing transport');\n    cleanup();\n    if ('open' === transport.readyState) {\n      transport.close();\n    }\n  }, this.server.upgradeTimeout);\n\n  function onPacket (packet) {\n    if ('ping' === packet.type && 'probe' === packet.data) {\n      transport.send([{ type: 'pong', data: 'probe' }]);\n      self.emit('upgrading', transport);\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = setInterval(check, 100);\n    } else if ('upgrade' === packet.type && self.readyState !== 'closed') {\n      debug('got upgrade packet - upgrading');\n      cleanup();\n      self.transport.discard();\n      self.upgraded = true;\n      self.clearTransport();\n      self.setTransport(transport);\n      self.emit('upgrade', transport);\n      self.setPingTimeout();\n      self.flush();\n      if (self.readyState === 'closing') {\n        transport.close(function () {\n          self.onClose('forced close');\n        });\n      }\n    } else {\n      cleanup();\n      transport.close();\n    }\n  }\n\n  // we force a polling cycle to ensure a fast upgrade\n  function check () {\n    if ('polling' === self.transport.name && self.transport.writable) {\n      debug('writing a noop packet to polling for fast upgrade');\n      self.transport.send([{ type: 'noop' }]);\n    }\n  }\n\n  function cleanup () {\n    self.upgrading = false;\n\n    clearInterval(self.checkIntervalTimer);\n    self.checkIntervalTimer = null;\n\n    clearTimeout(self.upgradeTimeoutTimer);\n    self.upgradeTimeoutTimer = null;\n\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('close', onTransportClose);\n    transport.removeListener('error', onError);\n    self.removeListener('close', onClose);\n  }\n\n  function onError (err) {\n    debug('client did not complete upgrade - %s', err);\n    cleanup();\n    transport.close();\n    transport = null;\n  }\n\n  function onTransportClose () {\n    onError('transport closed');\n  }\n\n  function onClose () {\n    onError('socket closed');\n  }\n\n  transport.on('packet', onPacket);\n  transport.once('close', onTransportClose);\n  transport.once('error', onError);\n\n  self.once('close', onClose);\n};\n\n/**\n * Clears listeners and timers associated with current transport.\n *\n * @api private\n */\n\nSocket.prototype.clearTransport = function () {\n  var cleanup;\n\n  var toCleanUp = this.cleanupFn.length;\n\n  for (var i = 0; i < toCleanUp; i++) {\n    cleanup = this.cleanupFn.shift();\n    cleanup();\n  }\n\n  // silence further transport errors and prevent uncaught exceptions\n  this.transport.on('error', function () {\n    debug('error triggered by discarded transport');\n  });\n\n  // ensure transport won't stay open\n  this.transport.close();\n\n  clearTimeout(this.pingTimeoutTimer);\n};\n\n/**\n * Called upon transport considered closed.\n * Possible reasons: `ping timeout`, `client error`, `parse error`,\n * `transport error`, `server close`, `transport close`\n */\n\nSocket.prototype.onClose = function (reason, description) {\n  if ('closed' !== this.readyState) {\n    this.readyState = 'closed';\n    clearTimeout(this.pingTimeoutTimer);\n    clearInterval(this.checkIntervalTimer);\n    this.checkIntervalTimer = null;\n    clearTimeout(this.upgradeTimeoutTimer);\n    var self = this;\n    // clean writeBuffer in next tick, so developers can still\n    // grab the writeBuffer on 'close' event\n    process.nextTick(function () {\n      self.writeBuffer = [];\n    });\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.clearTransport();\n    this.emit('close', reason, description);\n  }\n};\n\n/**\n * Setup and manage send callback\n *\n * @api private\n */\n\nSocket.prototype.setupSendCallback = function () {\n  var self = this;\n  this.transport.on('drain', onDrain);\n\n  this.cleanupFn.push(function () {\n    self.transport.removeListener('drain', onDrain);\n  });\n\n  // the message was sent successfully, execute the callback\n  function onDrain () {\n    if (self.sentCallbackFn.length > 0) {\n      var seqFn = self.sentCallbackFn.splice(0, 1)[0];\n      if ('function' === typeof seqFn) {\n        debug('executing send callback');\n        seqFn(self.transport);\n      } else if (Array.isArray(seqFn)) {\n        debug('executing batch send callback');\n        for (var l = seqFn.length, i = 0; i < l; i++) {\n          if ('function' === typeof seqFn[i]) {\n            seqFn[i](self.transport);\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Sends a message packet.\n *\n * @param {String} message\n * @param {Object} options\n * @param {Function} callback\n * @return {Socket} for chaining\n * @api public\n */\n\nSocket.prototype.send =\nSocket.prototype.write = function (data, options, callback) {\n  this.sendPacket('message', data, options, callback);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type\n * @param {String} optional, data\n * @param {Object} options\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, callback) {\n  if ('function' === typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  if ('closing' !== this.readyState && 'closed' !== this.readyState) {\n    debug('sending packet \"%s\" (%s)', type, data);\n\n    var packet = {\n      type: type,\n      options: options\n    };\n    if (data) packet.data = data;\n\n    // exports packetCreate event\n    this.emit('packetCreate', packet);\n\n    this.writeBuffer.push(packet);\n\n    // add send callback to object, if defined\n    if (callback) this.packetsFn.push(callback);\n\n    this.flush();\n  }\n};\n\n/**\n * Attempts to flush the packets buffer.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState &&\n                this.transport.writable &&\n                this.writeBuffer.length) {\n    debug('flushing buffer to transport');\n    this.emit('flush', this.writeBuffer);\n    this.server.emit('flush', this, this.writeBuffer);\n    var wbuf = this.writeBuffer;\n    this.writeBuffer = [];\n    if (!this.transport.supportsFraming) {\n      this.sentCallbackFn.push(this.packetsFn);\n    } else {\n      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n    }\n    this.packetsFn = [];\n    this.transport.send(wbuf);\n    this.emit('drain');\n    this.server.emit('drain', this);\n  }\n};\n\n/**\n * Get available upgrades for this socket.\n *\n * @api private\n */\n\nSocket.prototype.getAvailableUpgrades = function () {\n  var availableUpgrades = [];\n  var allUpgrades = this.server.upgrades(this.transport.name);\n  for (var i = 0, l = allUpgrades.length; i < l; ++i) {\n    var upg = allUpgrades[i];\n    if (this.server.transports.indexOf(upg) !== -1) {\n      availableUpgrades.push(upg);\n    }\n  }\n  return availableUpgrades;\n};\n\n/**\n * Closes the socket and underlying transport.\n *\n * @param {Boolean} optional, discard\n * @return {Socket} for chaining\n * @api public\n */\n\nSocket.prototype.close = function (discard) {\n  if ('open' !== this.readyState) return;\n\n  this.readyState = 'closing';\n\n  if (this.writeBuffer.length) {\n    this.once('drain', this.closeTransport.bind(this, discard));\n    return;\n  }\n\n  this.closeTransport(discard);\n};\n\n/**\n * Closes the underlying transport.\n *\n * @param {Boolean} discard\n * @api private\n */\n\nSocket.prototype.closeTransport = function (discard) {\n  if (discard) this.transport.discard();\n  this.transport.close(this.onClose.bind(this, 'forced close'));\n};\n"]},"metadata":{},"sourceType":"script"}